* Literate Paradigm Configuration File for Emacs - May 2019.

** Introduction.

TODO - description of what literate programming is and how it works
with Emacs and Org-mode.

** Information About Document Structure.

TODO - How document is broken down. Initial thoughts.

- Configuration required to get other things working.

- Appearance
    Set theme/appearance
    Set modeline theme
    Font configuration

- Programming
  - C/C++
    Python
    Clojure

- Text editing
  - HTML
    LaTeX
    Spell checking
    Text linting

** Package Management.

Over the years I have been using Emacs I have had to deal with various
approaches to the issue of plug-ins and packages.  For a long time it
seemed you had to download the code and unpack it somewhere
appropriate, then link that location in the configuration file,
compile the code etc. And while it worked almost all the time, it was
often messy, and if there were dependencies they had to be resolved
manually.

When I decided to start running the cutting edge Emacs versions (self
compiled) I decided that I should run the latest versions of the
packages as well and started pulling everything from their various Git
repositories. This worked quite well, and I could run a simple bash
process to update the packages as required, essentially walking the
folders and running 'git pull' for each package, and then recompiling
as required. It worked, but it was unneccesarily fiddly!

Then, along came the package repositories. These online stores provide
regularly updated lists of curated packages. The first block of code
below plumbs in the 'Melpa' repository. The packages may not be quite
as up to date as the Git repositories (though they are close) but
updating them is much simpler, involving running
'packages-list-packages', loading the package list, hitting u (update)
which will identify the packages for which there are updates, and the
x (eXecute) to update the packages that have an update available.

The second innovation was the 'use-package' plug-in. This allows
automatic installation of packages by giving '(use-package packname)'
in the code.

#+BEGIN_SRC emacs-lisp
  (require 'package)
  (add-to-list 'package-archives
  '("melpa-stable" . "https://stable.melpa.org/packages/") t)
  (package-initialize)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(require 'use-package)
#+END_SRC

** Appearance.

Out of the box Emacs isn't ugly, it is just staid. And it uses a lot
of screen real-estate which I can put to better use.

*** Reclaiming Screen Real-Estate.

Start by removing the unneccesary menu bar and tool bar from the top
of the screen and the scroll bar on the right hand side. Once that is
done I'll know the initialisation is working and I can commit the
first configuration.

#+BEGIN_SRC emacs-lisp
  (menu-bar-mode 0)			; Turn off menu bar
  (tool-bar-mode 0)			; Turn off tool bar
  (blink-cursor-mode 0)			; Stop cursor blinking
  (scroll-bar-mode 0)			; Don't need the scrollbar
  (display-time-mode 1)			; Do put time in mode line.
#+END_SRC

*** Switch Off the Start-Up Message.

I know that I'm using Emacs, I just started the program, so I don't
need to be reminded of that fact. This code switches off the start-up
message.

#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t)	; switch off splash screen.
#+END_SRC

*** Set A Nice Font.

If you are going to spend a lot of time looking at text, you might as
well make sure that it is a pleasant font to look at.

#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'default nil
  :font "Inconsolata Medium"
  :height 85)				; height 85 slightly easier to read.
#+END_SRC

There was a long discussion on Reddit (/r/emacs) about preferred fonts
for programming and the like. I think I like the font, but I may go
for a larger size.

TODO - track down the discussion and look at alternative recommendations.

*** Highlight the Current Line.

To help guide the eye when writing Emacs supports highlighting of the
current line (the line where the cursor is).

#+BEGIN_SRC emacs-lisp
  (global-hl-line-mode 1)			; highlight current line.
#+END_SRC

This highlighting is reliant on the colour scheme being used within
Emacs, so isn't always as useful as it is in this default setup where
the highlighted line has a green background against the white of the
rest of the screen.
*** Line Numbering.

As files get longer, being able to refer to a location by its line
number becomes more desirable.  This is especially the case when I
start dabbling in programming as it will help locate errors which I
will, inevitably make.

#+BEGIN_SRC emacs-lisp
  (global-linum-mode t)
#+END_SRC

*** Colour Theme.

Cyberpunk theme - first installation from Melpa using use-package.

#+BEGIN_SRC emacs-lisp
  (use-package cyberpunk-theme	;
  :ensure t)
#+END_SRC
*** Rainbow Delimiters.

On its surface, this functionality can appear to be just a bit of
prettiness, but the functionality is somewhat useful. When using a lot
of brackets (think Clojure/Lisp) it can be tricky to keep track of the
brackets.  Rainbow Delimiters uses a different colour for each pair of
brackets, making it easier to see which brackets match.

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
  :ensure t
  :config (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
  :config (add-hook 'LaTeX-mode-hook 'rainbow-delimiters-mode)
  :config (add-hook 'text-mode-hook 'rainbow-delimiters-mode)
  :config (add-hook 'org-mode-hook 'rainbow-delimiters-mode))
#+END_SRC

TODO This function also needs to be married to the electric pairs behaviour
so that brackets are created in pairs.

*** Doom Modeline.

This is a look and feel configuration that really packs a punch and
makes Emacs look a lot more modern than before.  Doom Modeline
supports its own range of themes which could be experimented with at
some point.

#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons)		; install 'all the icons' package
  (use-package doom-modeline
  :ensure t
  :hook (after-init . doom-modeline-mode))
  (use-package doom-themes
  :ensure t
  :config (load-theme 'doom-city-lights t))
#+END_SRC
** Version Control.

*** Magit - Git Porcelain for Emacs.

One of the 'killer apps' of Emacs is its Git supporting plug-in
'Magit'. It describes itself as a git porcelain (no, I don't know why
either!).

Magit is definitely a great way to manage Git repositories, and you
can do most things from within Emacs itself. I'm still getting to
grips with the functionality, but the effor feels worth it.

*** Magit Dependencies.

Before installing Magit itself, you need to take care of some
dependencies.

**** Dash

#+BEGIN_SRC emacs-lisp
  (use-package dash
  :ensure t)
#+END_SRC

**** Magit Pop-up

#+BEGIN_SRC emacs-lisp
  (use-package magit-popup
  :ensure t)
#+END_SRC

**** With Editor

#+BEGIN_SRC emacs-lisp
  (use-package with-editor
  :ensure t)
#+END_SRC

**** ghub

#+BEGIN_SRC emacs-lisp
  (use-package ghub
  :ensure t)
#+END_SRC

*** Magit itself

After all that, I can then get around to installing Magit itself. The
installation command is simple, but the configuration command binds
C-x g to 'magit status' which is the equivalent of git status. This
shows which files are unstaged, staged or untracked.

A lot of the commands in Magit are two steps. To view the log hit l
and then follow up appropriately. Hitting l again will give the log of
your currently checked out branch. Hitting b will display all the
branches.

#+BEGIN_SRC emacs-lisp
  (use-package magit
  :ensure t
  :config (global-set-key (kbd "C-x g") 'magit-status))
#+END_SRC

*** Magit Documentation.

Magit is complex, so documentation needs to be at hand.

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'info
  (info-initialize)
  (add-to-list 'Info-directory-list
  "~/.emacs.d/elpa/magit-2.90.1/dir/"))
#+END_SRC
*** Backups

By default Emacs creates a simple backup of files when editing. These
share the same file name but with an appended tilde (~) character.
This is okay, and, in those folders and projects which are under Git
control actually unnecessary, but for folders that aren't under this
level of version control it is a good idea to keep old copies of files
at each save point. This is especially the case, given that modern
systems tend to have lots of disc space, so keeping copies of these
files isn't an issue.

There are a number of variables which control how backups are kept and
managed, and the naming of the files doesn't alway do a sterling job
of indicating what they do.

**** Save Uniquified Backups To Single Location.

Rather than clogging up your working directory with backups this
configuration will save the old backups to a specified folder
elsewhere on the system.  I saw one configuration where the backup
folder is actually hidden (in the usual Unix manner, by starting with
a full stop). That way it doesn't even show up on many listings...

#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist '(("." . "~/.Backups/"))) ; hidden backup folder
  (setq delete-old-versions t)				    ; delete old versions silently
  (setq kept-new-versions 6)				    ; no. of new versions to keep
  (setq kept-old-versions 2)				    ; no. of old versions to keep.
  (setq version-control t)				    ; create numbered backups
  (setq vc-make-backup-files t)				    ; backup even version controlled files.
  (setq auto-save-file-name-transforms '((".*" "~/.Backups/" t))) ; uniquify saved names
#+END_SRC

This code block does the following:

- Sets the location for backups to be saved to (now ~/.Backups/)
- Sets the system to remove old versions (need to set upper and lower limits)
- Backup files even if they are under version control
- Process the file names that are used for backup so they are
  unique. The actual process is to take the full path of the file and
  convert all forward slashes into exclamation marks. The fact that
  the path is, by definition unique means the backups will be as well.
** General Behaviour.

These settings are the sort of thing that has a general effect on all
areas of using the editor.  Things like word wrapping and being able
to respond to queries using y/n rather than yes/no. These are not
specific to a particular activity or mode.

*** White Space Trimmming.

When a file is saved, this function is called and trims any excess
white space at the end of the file.  There are more aggressive
versions of this function which will strip out white space throughout
the document but I don't need that sort of functionality.

Wike article on the subject:

https://www.emacswiki.org/emacs/DeletingWhitespace

#+BEGIN_SRC emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

*** Answering yes/no Questions with Y/N.

Honestly, this is the 21st Century, who has time to type yes/no when
y/n will do the job? This is especially obvious when you do things
like 'kill-some-buffers' with the intention of closing a load of
windows one after the other. Having to type yes/no in that process
defeats the whole process.

More information on the wiki at:

https://www.emacswiki.org/emacs/YesOrNoP

#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC
*** Word Wrapping.

By default Emacs doesn't wrap the text entered.  This is obviously
nonsense in every circumstance, so this code block activates work
wrapping.

Information on word wrapping:

https://www.gnu.org/software/emacs/manual/html_node/emacs/Auto-Fill.html

Instructions on activating word wrapping (auto-fill-mode) here:

https://www.gnu.org/software/emacs/manual/html_node/efaq/Turning-on-auto_002dfill-by-defauâ”‚lt.html

It is worth noting that the word wrap happens when the line length
reaches a certain point. After that Emacs won't automatically try and
reflow the text a second time (cf. Word and other WYSIWYG editors).
As this is the case there are a couple of handy commands to refill
text and deal with the issue. These are described here:

https://www.gnu.org/software/emacs/manual/html_node/emacs/Fill-Commands.html#Fill-Commands

Most useful:

- M-q : fill the current paragraph. Note that a paragraph is defined
  as having a blank line between it and its neighbours. If there is no
  blank line then the paragraphs are treated as one and will be melded
  together.

- C-u 2 M-q : Fill the paragraph but justify both the right and left
  edges, not just the left hand one.

An example of the difference:

This is some text which I am going to format with a ragged right hand
edge.  The content of the paragraph really doesn't matter, the point
is to have a few lines of random text which we can justify as
required.

This is  some text which  I am going to  format with a  straight right
hand edge.   The content of  the paragraph really doesn't  matter, the
point is to  have a few lines  of random text which we  can justify as
required.

The problem with the second block is the extra spaces introduced to
create the straight right edge. In proper typesetting the extra space
can be spread along the length of the line, but in a simple fixed
width text the gaps are going to be obvious.

Still, quite cool functionality.

The code block below activates the word wrapping (auto-fill in Emacs
speak), for specific modes. I have added entries for the following
modes:

- text

- LaTeX

- latex

- Org-mode

- Emacs Lisp

- Fundamental

#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook 'auto-fill-mode)		; word
  (add-hook 'LaTeX-mode-hook 'auto-fill-mode)		; wrapping
  (add-hook 'latex-mode-hook 'auto-fill-mode)		; in these
  (add-hook 'org-mode-hook 'auto-fill-mode)		; various
  (add-hook 'emacs-lisp-mode-hook 'auto-fill-mode)	; modes
  (add-hook 'fundamental-mode-hook 'auto-fill-mode)		;
  (add-hook 'prog-mode-hook 'auto-fill-mode)
#+END_SRC

I don't think I will need to set a default mode now as all the
important ones are covered.

*** Recent Files.

A standard part of many programs, and operating systems, is to provide
quick access to files which have been opened recently. Emacs supports
this functionality via 'recentf'.

To view the list of files available having turned off the menu bar,
the command is:

M-x recentf-open-files

The code block provides a shortcut for this function so you can use:

C-x C-r

No-one is going to miss the original use of this shortcut which is to
open a file in read-only mode!

The ten most recent files can be selected simply by entering the
relevant digit (1-0). Other entries can be selected by highlighting
the required file and hitting return.

#+BEGIN_SRC emacs-lisp
  (require 'recentf)			; Ensure recentf is loaded
  (setq recentf-save-file '"~/.Backups/recentf") ; put recentf in ~/.Backups folder
  (recentf-mode 1)			; and activated
  (setq recentf-max-menu-items 25)	; Define how many recent entries to store
  (global-set-key "\C-x\ \C-r" 'recentf-open-files) ; map to key binding.
  (run-at-time nil (* 5 60) 'recentf-save-list)	  ; save list of recentf files every 5 minutes
#+END_SRC

The output when I hit C-x C-r as of writing this is:

  [1] /home/richard/.emacs.d/config.org
  [2] /home/richard/.emacs.d/recentf
*** Saving Your Place.

As files get longer it is useful to be able to open a file and return
to the same location as you were at when you closed the file or
shutdown the program.  This doesn't require any special commands, it
just stores the information in the ~/.Backups/ folder.

#+BEGIN_SRC emacs-lisp
  (setq save-place-file '"~/.Backups/places") ; put places file in ~/.Backups folder
  (save-place-mode 1)
#+END_SRC
