* Literate Paradigm Configuration File for Emacs - May 2019.

** Introduction.

TODO - description of what literate programming is and how it works
with Emacs and Org-mode.

** Information About Document Structure.

TODO - How document is broken down. Initial thoughts.

- Configuration required to get other things working.

- Appearance
    Set theme/appearance
    Set modeline theme
    Font configuration

- Programming
  - C/C++
    Python
    Clojure

- Text editing
  - HTML
    LaTeX
    Spell checking
    Text linting

** Package Management.

Over the years I have been using Emacs I have had to deal with various
approaches to the issue of plug-ins and packages.  For a long time it
seemed you had to download the code and unpack it somewhere
appropriate, then link that location in the configuration file,
compile the code etc. And while it worked almost all the time, it was
often messy, and if there were dependencies they had to be resolved
manually.

When I decided to start running the cutting edge Emacs versions (self
compiled) I decided that I should run the latest versions of the
packages as well and started pulling everything from their various Git
repositories. This worked quite well, and I could run a simple bash
process to update the packages as required, essentially walking the
folders and running 'git pull' for each package, and then recompiling
as required. It worked, but it was unneccesarily fiddly!

Then, along came the package repositories. These online stores provide
regularly updated lists of curated packages. The first block of code
below plumbs in the 'Melpa' repository. The packages may not be quite
as up to date as the Git repositories (though they are close) but
updating them is much simpler, involving running
'packages-list-packages', loading the package list, hitting u (update)
which will identify the packages for which there are updates, and the
x (eXecute) to update the packages that have an update available.

The second innovation was the 'use-package' plug-in. This allows
automatic installation of packages by giving '(use-package packname)'
in the code.

#+BEGIN_SRC emacs-lisp
  (require 'package)
  (add-to-list 'package-archives
  '("melpa-stable" . "https://stable.melpa.org/packages/") t)
  (package-initialize)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(require 'use-package)
#+END_SRC

** Appearance.

Out of the box Emacs isn't ugly, it is just staid. And it uses a lot
of screen real-estate which I can put to better use.

*** Reclaiming Screen Real-Estate.

Start by removing the unneccesary menu bar and tool bar from the top
of the screen and the scroll bar on the right hand side. Once that is
done I'll know the initialisation is working and I can commit the
first configuration.

#+BEGIN_SRC emacs-lisp
  (menu-bar-mode 0)			; Turn off menu bar
  (tool-bar-mode 0)			; Turn off tool bar
  (blink-cursor-mode 0)			; Stop cursor blinking
  (scroll-bar-mode 0)			; Don't need the scrollbar
  (display-time-mode 1)			; Do put time in mode line.
#+END_SRC

*** Switch Off the Start-Up Message.

I know that I'm using Emacs, I just started the program, so I don't
need to be reminded of that fact. This code switches off the start-up
message.

#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t)	; switch off splash screen.
#+END_SRC

*** Set A Nice Font.

If you are going to spend a lot of time looking at text, you might as
well make sure that it is a pleasant font to look at.

#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'default nil
  :font "Inconsolata Medium"
  :height 85)				; height 85 slightly easier to read.
#+END_SRC

There was a long discussion on Reddit (/r/emacs) about preferred fonts
for programming and the like. I think I like the font, but I may go
for a larger size.

TODO - track down the discussion and look at alternative recommendations.

*** Highlight the Current Line.

To help guide the eye when writing Emacs supports highlighting of the
current line (the line where the cursor is).

#+BEGIN_SRC emacs-lisp
  (global-hl-line-mode 1)			; highlight current line.
#+END_SRC

This highlighting is reliant on the colour scheme being used within
Emacs, so isn't always as useful as it is in this default setup where
the highlighted line has a green background against the white of the
rest of the screen.
*** Line Numbering.

As files get longer, being able to refer to a location by its line
number becomes more desirable.  This is especially the case when I
start dabbling in programming as it will help locate errors which I
will, inevitably make.

#+BEGIN_SRC emacs-lisp
  (global-linum-mode t)
#+END_SRC

*** Colour Theme.

Cyberpunk theme - first installation from Melpa using use-package.

#+BEGIN_SRC emacs-lisp
  (use-package cyberpunk-theme	;
  :ensure t)
#+END_SRC
*** Rainbow Delimiters.

On its surface, this functionality can appear to be just a bit of
prettiness, but the functionality is somewhat useful. When using a lot
of brackets (think Clojure/Lisp) it can be tricky to keep track of the
brackets.  Rainbow Delimiters uses a different colour for each pair of
brackets, making it easier to see which brackets match.

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
  :ensure t
  :config (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
  :config (add-hook 'LaTeX-mode-hook 'rainbow-delimiters-mode)
  :config (add-hook 'text-mode-hook 'rainbow-delimiters-mode)
  :config (add-hook 'org-mode-hook 'rainbow-delimiters-mode))
#+END_SRC

TODO This function also needs to be married to the electric pairs behaviour
so that brackets are created in pairs.

*** Doom Modeline.

This is a look and feel configuration that really packs a punch and
makes Emacs look a lot more modern than before.  Doom Modeline
supports its own range of themes which could be experimented with at
some point.

#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons)		; install 'all the icons' package
  (use-package doom-modeline
  :ensure t
  :hook (after-init . doom-modeline-mode))
  (use-package doom-themes
  :ensure t
  :config (load-theme 'doom-city-lights t))
#+END_SRC
** Version Control.

*** Magit - Git Porcelain for Emacs.

One of the 'killer apps' of Emacs is its Git supporting plug-in
'Magit'. It describes itself as a git porcelain (no, I don't know why
either!).

Magit is definitely a great way to manage Git repositories, and you
can do most things from within Emacs itself. I'm still getting to
grips with the functionality, but the effor feels worth it.

*** Magit Dependencies.

Before installing Magit itself, you need to take care of some
dependencies.

**** Dash

#+BEGIN_SRC emacs-lisp
  (use-package dash
  :ensure t)
#+END_SRC

**** Magit Pop-up

#+BEGIN_SRC emacs-lisp
  (use-package magit-popup
  :ensure t)
#+END_SRC

**** With Editor

#+BEGIN_SRC emacs-lisp
  (use-package with-editor
  :ensure t)
#+END_SRC

**** ghub

#+BEGIN_SRC emacs-lisp
  (use-package ghub
  :ensure t)
#+END_SRC

*** Magit itself

After all that, I can then get around to installing Magit itself. The
installation command is simple, but the configuration command binds
C-x g to 'magit status' which is the equivalent of git status. This
shows which files are unstaged, staged or untracked.

A lot of the commands in Magit are two steps. To view the log hit l
and then follow up appropriately. Hitting l again will give the log of
your currently checked out branch. Hitting b will display all the
branches.

#+BEGIN_SRC emacs-lisp
  (use-package magit
  :ensure t
  :config (global-set-key (kbd "C-x g") 'magit-status))
#+END_SRC

*** Magit Documentation.

Magit is complex, so documentation needs to be at hand.

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'info
  (info-initialize)
  (add-to-list 'Info-directory-list
  "~/.emacs.d/elpa/magit-2.90.1/dir/"))
#+END_SRC
*** Backups

By default Emacs creates a simple backup of files when editing. These
share the same file name but with an appended tilde (~) character.
This is okay, and, in those folders and projects which are under Git
control actually unnecessary, but for folders that aren't under this
level of version control it is a good idea to keep old copies of files
at each save point. This is especially the case, given that modern
systems tend to have lots of disc space, so keeping copies of these
files isn't an issue.

There are a number of variables which control how backups are kept and
managed, and the naming of the files doesn't alway do a sterling job
of indicating what they do.

**** Save Uniquified Backups To Single Location.

Rather than clogging up your working directory with backups this
configuration will save the old backups to a specified folder
elsewhere on the system.  I saw one configuration where the backup
folder is actually hidden (in the usual Unix manner, by starting with
a full stop). That way it doesn't even show up on many listings...

#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist '(("." . "~/.Backups/"))) ; hidden backup folder
  (setq delete-old-versions t)				    ; delete old versions silently
  (setq kept-new-versions 6)				    ; no. of new versions to keep
  (setq kept-old-versions 2)				    ; no. of old versions to keep.
  (setq version-control t)				    ; create numbered backups
  (setq vc-make-backup-files t)				    ; backup even version controlled files.
  (setq auto-save-file-name-transforms '((".*" "~/.Backups/" t))) ; uniquify saved names
#+END_SRC

This code block does the following:

- Sets the location for backups to be saved to (now ~/.Backups/)
- Sets the system to remove old versions (need to set upper and lower limits)
- Backup files even if they are under version control
- Process the file names that are used for backup so they are
  unique. The actual process is to take the full path of the file and
  convert all forward slashes into exclamation marks. The fact that
  the path is, by definition unique means the backups will be as well.
** General Behaviour.

These settings are the sort of thing that has a general effect on all
areas of using the editor.  Things like word wrapping and being able
to respond to queries using y/n rather than yes/no. These are not
specific to a particular activity or mode.

*** White Space Trimmming.

When a file is saved, this function is called and trims any excess
white space at the end of the file.  There are more aggressive
versions of this function which will strip out white space throughout
the document but I don't need that sort of functionality.

Wike article on the subject:

https://www.emacswiki.org/emacs/DeletingWhitespace

#+BEGIN_SRC emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC
